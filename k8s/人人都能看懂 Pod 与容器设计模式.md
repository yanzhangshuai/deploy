#### 容器的概念

> 容器本质是一个进程，是一个视图被隔离、资源受限的进程
> 容器内 PID=1 的进程就是应用本身。
> 管理虚拟机 = 管理基础设施：管理容器 = 直接管理应用本身




> Linux中线程是轻量级进程


#### 进程组概念

> **Pod** 是一个进程组的概念


> 容器的设计本身是一种 ”单线程“ 模型，由于容器的应用等于进程，所以只能去管理 PID=1 的进程，其它再起来的进程是一个托管状态。所以说服务应用进程本身就具有 ”进程管理“ 功能

> 由于容器实际上是一个 "单进程" 模型，所以如果在容器启动多个进程，只有一个可以作为 PID=1 的进程，而这时候，如果 PID=1 的进程挂了，那么其它进程就会成为 ”孤儿进程“，无法回收它们的资源

> Linux 容器的 ”单进程“ 模型，指的是容器生命周期等同于 PID=1 的进程（容器应用进程）的生命周期，而不是说容器不能创建多进程。

> 解决容器 ”多进程“ 问题 可以在容器 运行一个 **systemd** ，此 **systemd** 作为PID=1 的进程，专门用来管理其它进程，但是这样产生的问题是，容器的生命周期不在等于 容器应用生命周期，反而更加复杂


> 在K8S中， **Pod** 实际上就是 K8S 项目抽象出来的一个可以类比为进程组的概念。将多个进程定义在一个 **Pod**中，在同一 **Pod** 的进程可以做到资源共享


> **Pod** 在 K8S 中只是一个逻辑单位，并没有一个真实的东西对应说说是 **Pod**， 真正物理存在的东西，只有容器，或者说，多个容器的组合叫作 **Pod**

> **Pod** 是 K8S 分配资源的一个单位，因为里面的容器要共享某些资源，所以 **Pod** 也是 K8S 的原子调度单位。




**Pod** 中的容器是 ”超亲密关系“
* 容器之间的文件交换
* 容器之间的本地通信
* 容器之间的频繁调用，处于性能考虑
* 容器之间共享 Namespace


#### Pod 的实现机制

##### 共享网络

在 **Pod** 中，额外启动一个 **infra container** 小容器共享整个 **Pod** 的 **Network Namespace**

> **infra container** 大于100-200KB左右，由汇编编写，用于处于 ”暂停状态“，其它所有容器会通过 Join Namespace 方式加入到 **infra container** 的 **Network Namespace** ，所以，一个 **Pod** 中的所有容器，看到的网络视图是完全一样的（网络设备、IP地址、Mac地址等）。跟网络相关的信息，其实全是一份


> 在 **Pod** 中，一定有一个IP地址，是这个 **Pod** 的 **Network Namespace** 对应的地址，也是这个 **infra container** 的IP地址，所以所有容器看到的都一致，而其它所有网络资源，都是一个 **Pod** 一份，并且被 **Pod** 中所有容器共享。

> **Pod** 生命周期等同于 **infra container** 生命周期


##### 共享存储


**Pod** 实际上就是将 **Volume** 变成了 **Pod level**，然后所有同属于此 **Pod** 的容器共享所有的 **Volume**


#### 容器设计模式

##### Sidecar

在 **Pod** 中，定义一些执行主业务所需要的辅助工作的容器

* 日志收集
* Debug应用
* 应用监控
* 代理容器
* 适配器容器