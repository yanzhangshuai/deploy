
## Docker 容器

> 容器本身没有价值,有价值的是"容器编排"，编排主要是容器之间的关系。对象之间的关系比对象本身重要。


容器是一种沙盒技术。沙盒就是能够像一个集装箱一样，把你的应用“装”起来。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。



> 程序：静态表现是文件、动态表现为进程

> 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”

> docker：CGroups(Control Groups) 用来制造约束，Namespace 用来修改进程视图。




> Docker容器 其实就是操作系统在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器只能 “看” 到当前Namespace所限定的资源、文件、设备、状态或配置。而对于宿主机以及其它不想关的程序，就完全看不到了。


> Docker容器其实就是一种特殊的进程而已


> 对于宿主来说，这些被 “隔离” 的进程与其它进程没区别。


> Docker Engine 并没有像 Hypervisor 那样对应用进程的隔离环境负责，也不会创建任何实体的“容器”，真正对隔离环境负责的是宿主机操作系统本身。


> Docker容器其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 CGroups 配置的限制。


> **容器是一个 *单线程* 模型** ，用户的应用程序实际上就是容器里 PID=1 的进程，也是其它后续创建的所有进程的父进程， 也就是意味这，在一个容器中，没有办法*同时运行*两个不同的应用，除非能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是很多使用 **systemd** 和 **supervisord** 这样的软件代替应用本身作为容器的启用进程。


> 容器本身的设计，就是希望容器和应用能够 **同生命周期**，这个概念对容器编排非常重要。



Docker 最核心的原理实际上是为待创建的用户进程
    1. 启用Linux NameSpace 配置
    2. 设置指定的 CGroups 参数
    3. 切换进程的根目录（Change Root）

> Docker切换进程根目录优先使用 **pivot_root** 系统调用，如果系统不支持，才会使用 **chroot**

## 容器 与 虚拟机

> 容器与传统虚拟机的区别时：主要是隔离的边界不同，docker的隔离边界是系统用户层，由系统提供的namespace来做进程、文件系统的隔离。每一个镜像都具有一份软件隔离运行的基本要素，例如文件目录结构。从而达成实现软件层面运行的隔离。而传统虚拟机则由虚拟机引擎直接从硬件环境中进行隔离，虚拟机引擎为每一台虚拟机模拟出一个完整的运行环境，从而实现近乎彻底的隔离机制。


> 虚拟化技术作为应用沙盒，就必须由 Hypervisor 创建完整的虚拟机，整个虚拟机是真实存在的，并且内部必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免的带来了额外的资源消耗和占用。

> Docker 容器化 创建的应用，依然还是一个宿主机上普通进程，Docker只提供了运行时所需要隔离的配置文件。使用 Namespace 作为隔离手段进行运行应用。 这样运行的应用是直接运行在宿主机内，所以基本上不需要额外的性能损耗。


> "敏捷" 和 “高性能”是容器像相较于虚拟机的优势



相同点
1. 工作作用相同：容器和虚拟机都是为了实现应用运行的隔离边界问题
不同点：
1. 隔离边界不同：虚拟机是为应用提供完全的隔离环境，虚拟机软件为每台虚拟机模拟出一个接近完整的运行环境。每台虚拟机都有独自的硬件资源使用和独自的操作系统。
                容器则只是利用Linux宿主提供的 **Namespace** 和 **CGroups** 功能实现的隔离。本质上依然是宿主上普通的进程。Docker为每一个容器提供了软件应用隔离运行的基本要素，例如文件结构等。从而实现了软件应用层面的隔离界限

2. 工作原理不同：虚拟机通过硬件虚拟化功能，模拟出了一个操作系统运行所需要的各种硬件，然后在虚拟硬件中安装新的操作系统，
                容器的应用则是直接运行在 **宿主机** 里面。作为宿主机一个特殊参数设置的进程。容器通过 **rootfs** 根文件系统配置出一个软件运行的基础要素，运行时使用 **rootfs** 配置文件给进程设置对应参数。

3. 资源占用不同：虚拟机由于自身需要模拟各种硬件和运行时需要拦截处理虚拟机对宿主机的系统调用等，自身会占用不小的资源。
                容器由于是直接运行在宿主机内的一个特殊进程，在运行后所有的系统调用操作都是直接对宿主机本身的调用，所以基本上并不会有额外的资源损耗。

4. 使用场景不同：虚拟机技术由于模拟出了一个完整的系统应用环境，所以一般用于云服务厂商提供的云服务。
                容器由于提供了一个软件应用运行的隔离沙盒，所以一般用于纯软件服务厂商


## Namespace

> Namespace 技术实际上修改了应用进程看待整个计算机的“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定内容。 


Namespace： 
1. PID Namespace：      隔离进程。使用方法就是Linux在创建新进程时设置的一个可选参数。
2. Mount Namespace：    隔离挂载点信息。
3. UTS Namespace：
4. IPC Namespace：
5. Network Namespace:   隔离网络设备和网络配置
6. User Namespace：     隔离用户 


基于Namespace隔离的限制
1. **隔离的不彻底** 容器之间使用的还是同一个宿主机的操作系统内核。即共享宿主机内核。这意味着，如果要在Windows 宿主机运行 Linux 容器或者在低版本的 Linux 宿主机运行高版本的 Linux 容器，都行不通
2. 在Linux 内核中，许多资源和对象是不能被 Namespace 化的，最典型的例子就是 **时间**，如果容器中程序使用 `settimeofday(2)`系统调用修改了时间，整个宿主机时间都会改变。


## Control Group

虽然容器使用了 Namespace 隔离了进程，使其内部无法看到其它资源。但对于宿主机本身，容器进程与其它进程没有区别，对于资源的使用依然是平等的竞争关系。所以需要对容器使用资源进行限制。

> **Linux Croups（Linux Control Group）** 就是Linux内核中用来为进程设置资源限制的一个重要功能，Docker容器使用的此功能进行的资源限制。

**Linux Croups** 作用
1. 主要作用是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络宽带等。
2. 对进程优先级设置、审计，以及将进程挂起和恢复等操作。



## rootfs

> Mount Namespace 是修改 **容器进程** 对文件系统 **挂载点** 的认知，只有在 **挂载** 这个操作发生之后，进程的视图才会被改变。而在此之前新容器会 **直接继承** 宿主主机的 **挂载点**。

> Mount Namespace 对容器进程视图的改变，一定会伴随着挂载操作（mount）才能生效

> Linux 具有一个 **chroot** 命令 允许改变进程的根目录到指定的位置。 Mount Namespace正是基于此命令改良完善的。

> 挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是所谓的 **容器镜像**，名字叫做 **rootf(根文件系统)**

> rootfs 只是操作系统所包含的文件、配置和目录，并不包括操作系统内核。在Linux操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像

> rootfs 打包的是整个操作系统的文件和目录。会将应用及应用运行所需要的所有依赖，都封装在一起。这种深入操作系统级别的运行环境一致性，打通了应用在本地开发和远程执行环境之间难以逾越的鸿沟。


> Docker 设计中，rootfs设计为以增量方式修改，而不是直接修改。

> Docker 镜像设计中， 引入了 **层（layer）** 的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量rootfs，这是使用到了一种叫作 **联合文件系统(Union File System)** 能力


> **Union File System** 主要功能是将多个位置的目录联合挂载（union mount）到同一目录下。


> Docker 镜像实际上就是 rootfs

容器的rootfs由三部分构成
1. 只读层：这是镜像包含的rootfs，镜像是只读的
2. Init层：这是一个以 *-init* 结尾的层，夹在只读层和读写层之间。**Init层** 是Docker项目单独生成的一个内部层，专门用来存放 `/etc/hosts`、 `/etc/resolv.conf` 等信息，
    需要这一层的原因是 用户往往在启用容器时写入一些指定的值，比如：**hostname**，所以需要在可读写层进行修改，但是这些修改往往只对当前容器生效，并不希望在执行 `docker commit` 时把这些信息带入，所以Docker提供了 **Init 层**
3，可读写层：这是在启动容器时在 镜像只读层之上创建的一个可读写层。在没有写入文件之前，这个目录是空的，一旦在容器中做了写操作，
    修改产生的内容就会以增量方式出现在这个层中，然后进行 **遮挡** 只读层的rootfs。还可以使用 `docker commit`指令将此层做的修改与其它只读层合并为一个新的镜像，供别人使用。




* [DOCKER基础技术：LINUX NAMESPACE（上）](https://coolshell.cn/articles/17010.html)\
* [白话容器基础（二）：隔离与限制](https://time.geekbang.org/column/article/14653)
* [Docker 核心技术与实现原理](https://www.infoq.cn/article/klmE24B59vHLEGN9zTLE?utm_source=related_read_bottom&utm_medium=article)
* [Docker 原理剖析（三）rootfs](https://blog.csdn.net/Geffin/article/details/109741226)
* [虚拟化技术 - 概览 [一]](https://zhuanlan.zhihu.com/p/69629212)
* [虚拟化技术 - CPU虚拟化](https://zhuanlan.zhihu.com/p/69625751)
* [了解以及区分物理机，虚拟机(hypervisor/VMM) 和 容器(Docker)的适用场景](https://blog.csdn.net/baiyan83/article/details/110182411)













// TODO：问题
1. docker windows、docker mac 运行机制
2. 容器为宿主进程，那么为什么可以在容器中执行其它命令